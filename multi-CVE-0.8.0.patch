From 392863c733a5dc777ff79b113cb58491d04a4daa Mon Sep 17 00:00:00 2001
From: Olav Morken <olav.morken@uninett.no>
Date: Thu, 3 Jul 2014 11:39:29 +0200
Subject: [PATCH 1/6] Fix access of uninitialized data when logging out.

Since the session data for an unused session isn't initialized,
we may end up reading uninitialized data, leading to a segmentation
fault.
---
 auth_mellon_cache.c |    5 +++++
 1 files changed, 5 insertions(+), 0 deletions(-)

diff --git a/auth_mellon_cache.c b/auth_mellon_cache.c
index 70c4879..308fc84 100644
--- a/auth_mellon_cache.c
+++ b/auth_mellon_cache.c
@@ -78,6 +78,11 @@ am_cache_entry_t *am_cache_lock(server_rec *s,
     for(i = 0; i < mod_cfg->init_cache_size; i++) {
         const char *tablekey;
 
+        if (table[i].key[0] == '\0') {
+            /* This entry is empty. Skip it. */
+            continue;
+        }
+
         switch (type) {
         case AM_CACHE_SESSION:
             tablekey = table[i].key;
-- 
1.7.4

From d29de0b81822e2ee98a4098eb2fa8877a82f298d Mon Sep 17 00:00:00 2001
From: Olav Morken <olav.morken@uninett.no>
Date: Wed, 27 Aug 2014 15:02:46 +0200
Subject: [PATCH 2/6] Move session table initialization into session file.

This moves all the code working on the session table to that file.
---
 auth_mellon.h       |    1 +
 auth_mellon_cache.c |   20 ++++++++++++++++++++
 mod_auth_mellon.c   |    9 ++-------
 3 files changed, 23 insertions(+), 7 deletions(-)

diff --git a/auth_mellon.h b/auth_mellon.h
index c6a10b3..e915cbf 100644
--- a/auth_mellon.h
+++ b/auth_mellon.h
@@ -329,6 +329,7 @@ void am_cookie_set(request_rec *r, const char *id);
 void am_cookie_delete(request_rec *r);
 
 
+void am_cache_init(am_mod_cfg_rec *mod_cfg);
 am_cache_entry_t *am_cache_lock(server_rec *s, 
                                 am_cache_key_t type, const char *key);
 const char *am_cache_entry_get_string(am_cache_entry_t *e,
diff --git a/auth_mellon_cache.c b/auth_mellon_cache.c
index 308fc84..5031d20 100644
--- a/auth_mellon_cache.c
+++ b/auth_mellon_cache.c
@@ -21,6 +21,26 @@
 
 #include "auth_mellon.h"
 
+/* Initialize the session table.
+ *
+ * Parameters:
+ *  am_mod_cfg_rec *mod_cfg  The module configuration.
+ *
+ * Returns:
+ *  Nothing.
+ */
+void am_cache_init(am_mod_cfg_rec *mod_cfg)
+{
+    am_cache_entry_t *table;
+    int i;
+    /* Initialize the session table. */
+    table = apr_shm_baseaddr_get(mod_cfg->cache);
+    for (i = 0; i < mod_cfg->cache_size; i++) {
+        table[i].key[0] = '\0';
+        table[i].access = 0;
+    }
+}
+
 /* This function locks the session table and locates a session entry.
  * Unlocks the table and returns NULL if the entry wasn't found.
  * If a entry was found, then you _must_ unlock it with am_cache_unlock
diff --git a/mod_auth_mellon.c b/mod_auth_mellon.c
index fc34962..545598b 100644
--- a/mod_auth_mellon.c
+++ b/mod_auth_mellon.c
@@ -45,10 +45,9 @@
 static int am_global_init(apr_pool_t *conf, apr_pool_t *log,
                           apr_pool_t *tmp, server_rec *s)
 {
-    am_cache_entry_t *table;
     apr_size_t        mem_size;
     am_mod_cfg_rec   *mod;
-    int rv, i;
+    int rv;
     const char userdata_key[] = "auth_mellon_init";
     char buffer[512];
     void *data;
@@ -108,11 +107,7 @@ static int am_global_init(apr_pool_t *conf, apr_pool_t *log,
     }
 
     /* Initialize the session table. */
-    table = apr_shm_baseaddr_get(mod->cache);
-    for (i = 0; i < mod->cache_size; i++) {
-        table[i].key[0] = '\0';
-        table[i].access = 0;
-    }
+    am_cache_init(mod);
 
     /* Now create the mutex that we need for locking the shared memory, then
      * test for success. we really need this, so we exit on failure. */
-- 
1.7.4

From 7e8dc087ddad0df98ea58854ebba8e00a4546a2f Mon Sep 17 00:00:00 2001
From: Olav Morken <olav.morken@uninett.no>
Date: Wed, 27 Aug 2014 15:14:18 +0200
Subject: [PATCH 3/6] Fix offset calculation for session entries.

The session entry size isn't known on compile time, so we must
actually calculate the offset at runtime.

This fixes a nasty bug where we would randomly overwrite session
entries.
---
 auth_mellon_cache.c |   42 +++++++++++++++++++++++++++++++-----------
 1 files changed, 31 insertions(+), 11 deletions(-)

diff --git a/auth_mellon_cache.c b/auth_mellon_cache.c
index 5031d20..1b45712 100644
--- a/auth_mellon_cache.c
+++ b/auth_mellon_cache.c
@@ -21,6 +21,24 @@
 
 #include "auth_mellon.h"
 
+/* Calculate the pointer to a cache entry.
+ *
+ * Parameters:
+ *  am_mod_cfg_rec *mod_cfg  The module configuration.
+ *  void *table              The base pointer for the table.
+ *  apr_size_t index         The index we are looking for.
+ *
+ * Returns:
+ *  The session entry with the given index.
+ */
+static inline am_cache_entry_t *am_cache_entry_ptr(am_mod_cfg_rec *mod_cfg,
+                                                   void *table, apr_size_t index)
+{
+    uint8_t *table_calc;
+    table_calc = table;
+    return (am_cache_entry_t *)&table_calc[mod_cfg->init_entry_size * index];
+}
+
 /* Initialize the session table.
  *
  * Parameters:
@@ -31,13 +49,14 @@
  */
 void am_cache_init(am_mod_cfg_rec *mod_cfg)
 {
-    am_cache_entry_t *table;
-    int i;
+    void *table;
+    apr_size_t i;
     /* Initialize the session table. */
     table = apr_shm_baseaddr_get(mod_cfg->cache);
     for (i = 0; i < mod_cfg->cache_size; i++) {
-        table[i].key[0] = '\0';
-        table[i].access = 0;
+        am_cache_entry_t *e = am_cache_entry_ptr(mod_cfg, table, i);
+        e->key[0] = '\0';
+        e->access = 0;
     }
 }
 
@@ -59,8 +78,8 @@ am_cache_entry_t *am_cache_lock(server_rec *s,
                                 const char *key)
 {
     am_mod_cfg_rec *mod_cfg;
-    am_cache_entry_t *table;
-    int i;
+    void *table;
+    apr_size_t i;
     int rv;
     char buffer[512];
 
@@ -96,20 +115,21 @@ am_cache_entry_t *am_cache_lock(server_rec *s,
 
 
     for(i = 0; i < mod_cfg->init_cache_size; i++) {
+        am_cache_entry_t *e = am_cache_entry_ptr(mod_cfg, table, i);
         const char *tablekey;
 
-        if (table[i].key[0] == '\0') {
+        if (e->key[0] == '\0') {
             /* This entry is empty. Skip it. */
             continue;
         }
 
         switch (type) {
         case AM_CACHE_SESSION:
-            tablekey = table[i].key;
+            tablekey = e->key;
             break;
         case AM_CACHE_NAMEID:
             /* tablekey may be NULL */
-            tablekey = am_cache_env_fetch_first(&table[i], "NAME_ID");
+            tablekey = am_cache_env_fetch_first(e, "NAME_ID");
             break;
         default:
             tablekey = NULL;
@@ -121,9 +141,9 @@ am_cache_entry_t *am_cache_lock(server_rec *s,
 
         if(strcmp(tablekey, key) == 0) {
             /* We found the entry. */
-            if(table[i].expires > apr_time_now()) {
+            if(e->expires > apr_time_now()) {
                 /* And it hasn't expired. */
-                return &table[i];
+                return e;
             }
         }
     }
-- 
1.7.4

From 86333fa66631885546242660ae5cecf5dfec4fa2 Mon Sep 17 00:00:00 2001
From: Olav Morken <olav.morken@uninett.no>
Date: Wed, 27 Aug 2014 15:27:30 +0200
Subject: [PATCH 4/6] Fix am_cache_env_fetch_first.

This function is supposed to return the value of the entry we are
looking for, but instead it returned the name. Fix it to return the
value.

Also, fix exit condition on for-loop.

This fixes NameID-based logout.
---
 auth_mellon_cache.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/auth_mellon_cache.c b/auth_mellon_cache.c
index 1b45712..80eb7c3 100644
--- a/auth_mellon_cache.c
+++ b/auth_mellon_cache.c
@@ -489,12 +489,12 @@ const char *am_cache_env_fetch_first(am_cache_entry_t *t,
     const char *str;
     int i;
 
-    for (i = 0; t->size; i++) {
+    for (i = 0; i < t->size; i++) {
         str = am_cache_entry_get_string(t, &t->env[i].varname);
         if (str == NULL)
             break;
         if (strcmp(str, var) == 0)
-            return str;
+            return am_cache_entry_get_string(t, &t->env[i].value);
     }
 
     return NULL;
-- 
1.7.4

From 013faf8d081d7fc102922e250ac0c0c4ca625995 Mon Sep 17 00:00:00 2001
From: Olav Morken <olav.morken@uninett.no>
Date: Mon, 1 Sep 2014 10:07:07 +0200
Subject: [PATCH 5/6] Fix session offset bug with creating new session.

When fixing the session offset calculation in 22990058be, I forgot
to update the logic for creating the new session. The result is that
the code for creating new sessions use a different logic for
calculating the session offset than the code for looking up sessions.

This in turn means that we can only have a single session.
---
 auth_mellon_cache.c |   17 +++++++++--------
 1 files changed, 9 insertions(+), 8 deletions(-)

diff --git a/auth_mellon_cache.c b/auth_mellon_cache.c
index 80eb7c3..3c41f23 100644
--- a/auth_mellon_cache.c
+++ b/auth_mellon_cache.c
@@ -278,7 +278,7 @@ am_cache_entry_t *am_cache_new(server_rec *s, const char *key)
 {
     am_cache_entry_t *t;
     am_mod_cfg_rec *mod_cfg;
-    am_cache_entry_t *table;
+    void *table;
     apr_time_t current_time;
     int i;
     apr_time_t age;
@@ -313,7 +313,7 @@ am_cache_entry_t *am_cache_new(server_rec *s, const char *key)
      * initalize it to the first entry in the table to simplify the
      * following code (saves test for t == NULL).
      */
-    t = &table[0];
+    t = am_cache_entry_ptr(mod_cfg, table, 0);
 
     /* Iterate over the session table. Update 't' to match the "best"
      * entry (the least recently used). 't' will point a free entry
@@ -321,25 +321,26 @@ am_cache_entry_t *am_cache_new(server_rec *s, const char *key)
      * used entry.
      */
     for(i = 0; i < mod_cfg->init_cache_size; i++) {
-        if(table[i].key[0] == '\0') {
+        am_cache_entry_t *e = am_cache_entry_ptr(mod_cfg, table, i);
+        if (e->key[0] == '\0') {
             /* This entry is free. Update 't' to this entry
              * and exit loop.
              */
-            t = &table[i];
+            t = e;
             break;
         }
 
-        if(table[i].expires <= current_time) {
+        if (e->expires <= current_time) {
             /* This entry is expired, and is therefore free.
              * Update 't' and exit loop.
              */
-            t = &table[i];
+            t = e;
             break;
         }
 
-        if(table[i].access < t->access) {
+        if (e->access < t->access) {
             /* This entry is older than 't' - update 't'. */
-            t = &table[i];
+            t = e;
         }
     }
 
-- 
1.7.4

